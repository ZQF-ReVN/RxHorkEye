#include <Windows.h>

#include "../TDA/MemX.h"
#include "../TDA/DetoursX.h"
#include "../TDA/ConsoleX.h"
#include "../ACV1Extract/ACV1Extract.h"


static DWORD g_dwExeBase = (DWORD)GetModuleHandleW(NULL);


VOID PatchMenu();
VOID PatchUIText();
VOID PatchBattle();
VOID PatchBracket();
VOID PatchCharset();
VOID PatchGBK2Unicode();
VOID PatchCharacterName();
VOID PatchGBKRangeTable();
VOID ScriptFileRedirection();


VOID StartHook()
{
	//TDA::ConsoleX::SetConsole(L"HanaHime");

	PatchMenu();
	PatchUIText();
	PatchBattle();
	PatchBracket();
	PatchCharset();
	PatchGBK2Unicode();
	PatchGBKRangeTable();
	//PatchCharacterName(); // If no change the character name there would be no need to call this func
	//ScriptFileRedirection(); //script.dat -> scrtipt.cn

	SetFileHook("FileHook/", 0xBF710);
	//SetFileExtract("Extract/");
	//SetFileDump("Dump/");
	SetScriptHook(0xCE9B0, 0xB66E0, "FileHook/Script/");
	//SetScriptDump(0xCE9B0, 0xB66E0, "Dump\\Script\\");

	TDA::DetoursX::HookCreateFontIndirectA(0x86, "黑体");
	TDA::DetoursX::HookTitleExA("niqAu\[gI1.30", "ハナヒメ＊アブソリュ`ト！1.30");
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		StartHook();
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}

VOID __declspec(dllexport) DirA() {}


static SHORT g_pChar[2] = { 0 };
static WCHAR g_pWChar[2] = { 0 };
static DWORD g_GBK2UnicodeRaw, g_GBK2UnicodeRet;
VOID __declspec(naked) GBK2Unicode()
{
	__asm
	{
		pushad;
		pushfd;
		mov bx, ax;
		shr bx, 8;
		shl ax, 8;
		or ax, bx;
		mov g_pChar, ax;
	}

	MultiByteToWideChar(0x3A8, NULL, (CHAR*)g_pChar, 2, g_pWChar, 2);

	__asm
	{
		popfd
		popad;
		mov ax, g_pWChar;
		jmp g_GBK2UnicodeRet;
	}
}

typedef HMODULE(WINAPI* pLoadLibraryA)(LPCSTR lpLibFileName);
static pLoadLibraryA RawLoadLibraryA = LoadLibraryA;
HMODULE WINAPI NewLoadLibraryA(LPCSTR lpLibFileName)
{
	HMODULE hModule = RawLoadLibraryA(lpLibFileName);

	if (!strcmp(lpLibFileName, "plugin/battle.dll"))
	{
		BYTE patch1[] = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 };
		TDA::MemX::WriteMemory((LPVOID)((DWORD)hModule + 0x238BAB), patch1, sizeof(patch1));
		TDA::MemX::WriteMemory((LPVOID)((DWORD)hModule + 0x239457), patch1, sizeof(patch1));

		BYTE patch2[] = { 0xEB };
		TDA::MemX::WriteMemory((LPVOID)((DWORD)hModule + 0x23B5CF), patch2, sizeof(patch2));
	}

	return hModule;
}

/*
「    SJIS 0x8175  GBK 0xA1B8
『    SJIS 0x8177  GBK 0xA1BA
（   SJIS 0x8169  GBK 0xA3A8
*/
static DWORD g_dwBracketRaw = 0;
static DWORD g_dwBracketIS = 0;
static DWORD g_dwBracketNO = 0;
VOID __declspec(naked) FixBracket()
{
	__asm
	{
		cmp cl, 0xA1;
		jl NO;
		cmp al, 0xB8;
		je IS;
		cmp al, 0xBA;
		je IS;
		cmp cl, 0xA3;
		jne NO;
		cmp al, 0xA8;
		je IS;

	NO:
		jmp g_dwBracketNO;
	IS:
		jmp g_dwBracketIS;
	}
}


VOID PatchMenu()
{
	// × -> ×
	static UCHAR aX[] = { 0xA1, 0xC1, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BBF54), aX, sizeof(aX));

	// ＋ -> ＋
	static UCHAR aPlus[] = { 0xA3, 0xAB, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BBF50), aPlus, sizeof(aPlus));

	//画面 -> 画面
	static UCHAR aPaint[] = { 0xBB, 0xAD, 0xC3, 0xE6 ,0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC0E8), aPaint, sizeof(aPaint));

	//スクリ`ンモ`ド  ->  显示模式
	static UCHAR aScreenMode[] = { 0xCF, 0xD4, 0xCA, 0xBE, 0xC4, 0xA3, 0xCA, 0xBD, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC0D4), aScreenMode, sizeof(aScreenMode));

	//ウィンドウ  ->  窗口
	static UCHAR aWindow[] = { 0xB4, 0xB0, 0xBF, 0xDA, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC0C8), aWindow, sizeof(aWindow));

	//フルスクリ`ン  ->  全屏
	static UCHAR aFullScreen [] = { 0xC8, 0xAB, 0xC6, 0xC1, 0x00};
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC0B8), aFullScreen, sizeof(aFullScreen));

	//アスペクト比 16:9  -> 16:9
	static UCHAR a16x9[] = { 0x31, 0x36, 0x3A, 0x39, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC0A4), a16x9, sizeof(a16x9));

	//アスペクト比  4:3  ->  4:3
	static UCHAR a4x3[] = { 0x34, 0x3A, 0x33, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC090), a4x3, sizeof(a4x3));

	//ウィンドウ位置  ->  窗口位置
	static UCHAR aWindowPosition[] = { 0xB4, 0xB0, 0xBF, 0xDA, 0xCE, 0xBB, 0xD6, 0xC3, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC06C), aWindowPosition, sizeof(aWindowPosition));

	//常に最前面で表示  ->  置顶窗口
	static UCHAR aWindowTop[] = { 0xD6, 0xC3, 0xB6, 0xA5, 0xB4, 0xB0, 0xBF, 0xDA, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC040), aWindowTop, sizeof(aWindowTop));

	//座摔虮３  ->  保持位置
	static UCHAR aWindowMaintain[] = { 0xB1, 0xA3, 0xB3, 0xD6, 0xCE, 0xBB, 0xD6, 0xC3, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC054), aWindowMaintain, sizeof(aWindowMaintain));

	//画面の中央  ->  屏幕居中
	static UCHAR aWindowCenter[] = { 0xC6, 0xC1, 0xC4, 0xBB, 0xBE, 0xD3, 0xD6, 0xD0, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC060), aWindowCenter, sizeof(aWindowCenter));

	//ウィンドウサイズ  ->  窗口大小
	static UCHAR aWindowSize[] = { 0xB4, 0xB0, 0xBF, 0xDA, 0xB4, 0xF3, 0xD0, 0xA1, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC07C), aWindowSize, sizeof(aWindowSize));

	//フルスクリ`ンモ`ド  ->  全屏模式
	static UCHAR aFullScreenMode[] = { 0xC8, 0xAB, 0xC6, 0xC1, 0xC4, 0xA3, 0xCA, 0xBD, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC028), aFullScreenMode, sizeof(aFullScreenMode));

	//画面大s小ag  ->  缩放算法
	static UCHAR aScaling[] = { 0xCB, 0xF5, 0xB7, 0xC5, 0xCB, 0xE3, 0xB7, 0xA8, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BBFE8), aScaling, sizeof(aScaling));

	//垂直同期待ち  ->  垂直同步
	static UCHAR aSync[] = { 0xB4, 0xB9, 0xD6, 0xB1, 0xCD, 0xAC, 0xB2, 0xBD, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BBF7C), aSync, sizeof(aSync));

	//同期o  ->  关闭同步
	static UCHAR aOffSync[] = { 0xB9, 0xD8, 0xB1, 0xD5, 0xCD, 0xAC, 0xB2, 0xBD, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BBF70), aOffSync, sizeof(aOffSync));

	//サイズ固定  ->  固定大小
	static UCHAR aFixSize[] = { 0xB9, 0xCC, 0xB6, 0xA8, 0xB4, 0xF3, 0xD0, 0xA1, 0x28, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BBF44), aFixSize, sizeof(aFixSize));

	//等倍  ->  原始
	static UCHAR aEqual[] = { 0xD4, 0xAD, 0xCA, 0xBC };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC155), aEqual, sizeof(aEqual));
}

VOID PatchUIText()
{
	//起釉O定  ->  启动设置
	static UCHAR aBootSetup[] = { 0xC6, 0xF4, 0xB6, 0xAF, 0xC9, 0xE8, 0xD6, 0xC3, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC444), aBootSetup, sizeof(aBootSetup));

	//スクリ`ンモ`ド  ->  显示模式
	static UCHAR aDisplayMode[] = { 0xCF, 0xD4, 0xCA, 0xBE, 0xC4, 0xA3, 0xCA, 0xBD,0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC0D4), aDisplayMode, sizeof(aDisplayMode));

	//ウィンドウ  ->  窗口
	static UCHAR aWindow[] = { 0xB4, 0xB0, 0xBF, 0xDA, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC0C8), aWindow, sizeof(aWindow));

	//フルスクリ`ン  ->  全屏
	static UCHAR aFullScreen[] = { 0xC8, 0xAB, 0xC6, 0xC1,0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC0B8), aFullScreen, sizeof(aFullScreen));

	//１６：９比率  ->  16:9
	static UCHAR a16x9[] = { 0x31, 0x36, 0xA3, 0xBA, 0x39, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC3DC), a16x9, sizeof(a16x9));

	//４：３比率  ->  4:3
	static UCHAR a4x3[] = { 0x34, 0xA3, 0xBA, 0x33, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC3D0), a4x3, sizeof(a4x3));

	//スクリ`ン解像度  ->  分辨率
	static UCHAR aResolution[] = { 0xB7, 0xD6, 0xB1, 0xE6, 0xC2, 0xCA, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC3BC), aResolution, sizeof(aResolution));

	//ウィンドウサイズをスクリ`ン解像度に合わせる  ->  适配屏幕分辨率
	static UCHAR aAdjustSize[] = { 0xCA, 0xCA, 0xC5, 0xE4, 0xC6, 0xC1, 0xC4, 0xBB, 0xB7, 0xD6, 0xB1, 0xE6, 0xC2, 0xCA, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC384), aAdjustSize, sizeof(aAdjustSize));

	//注意事项
	static UCHAR aNote[] =
	{
		0xB8, 0xDF, 0xB7, 0xD6, 0xB1, 0xE6, 0xC2, 0xCA,
		0xD0, 0xE8, 0xD2, 0xAA, 0xB8, 0xFC, 0xB8, 0xDF, 0xB5, 0xC4, 0xD3, 0xB2, 0xBC, 0xFE, 0xD0, 0xD4,
		0xC4, 0xDC, 0xD6, 0xA7, 0xB3, 0xD6, 
		0x0A,
		0x44, 0x42, 0x44, 0x20, 0x28, 0x44, 0x6F, 0x74,
		0x20, 0x42, 0x79, 0x20, 0x44, 0x6F, 0x74, 0x29, 0x20, 0xBC, 0xB4, 0xB5, 0xE3, 0xB6, 0xD4, 0xB5,
		0xE3, 0xCF, 0xD4, 0xCA, 0xBE, 0x00
	};
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC2E8), aNote, sizeof(aNote));

	//存档位置1
	static UCHAR aSvaePath[] =
	{
		0xCA, 0xC7, 0xB7, 0xF1, 0xC9, 0xE8, 0xD6, 0xC3, 0xCE, 0xC4, 0xB5, 0xB5, 0xCE, 0xAA, 0xB4, 0xE6,
		0xB5, 0xB5, 0xC4, 0xAC, 0xC8, 0xCF, 0xCE, 0xBB, 0xD6, 0xC3, 0xA3, 0xBF, 
		0x0A,
		0xD1, 0xA1, 0xB7, 0xF1, 0xBF, 0xC9, 0xD2, 0xD4, 0xC9, 0xE8, 0xD6, 0xC3, 0xB4, 0xE6, 0xB5, 0xB5, 
		0xCE, 0xBB, 0xD6, 0xC3, 0xCE, 0xAA, 0xC4, 0xBF, 0xC2, 0xBC, 0xCF, 0xC2, 0x00
	};
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BBE90), aSvaePath, sizeof(aSvaePath));

	//存档位置2
	static UCHAR aSvaePath2[] =
	{
		0xCA, 0xC7, 0xB7, 0xF1, 0xC9, 0xE8, 0xD6, 0xC3, 0xB4, 0xE6, 0xB5, 0xB5, 0xC2, 0xB7, 0xBE, 0xB6,
		0xCE, 0xAA, 0xD3, 0xCE, 0xCF, 0xB7, 0xC4, 0xBF, 0xC2, 0xBC, 0xCF, 0xC2, 0xA3, 0xBF, 0x00, 
	};
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BBE38), aSvaePath2, sizeof(aSvaePath2));

	//存档位置3
	static UCHAR aSvaePath3[] = { 0xB4, 0xE6, 0xB5, 0xB5, 0xC2, 0xB7, 0xBE, 0xB6, 0xCE, 0xAA, 0x0A, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BBE64), aSvaePath3, sizeof(aSvaePath3));

	//下次启动显示设置界面
	static UCHAR aNext[] =
	{
		0xCF, 0xC2, 0xB4, 0xCE, 0xC6, 0xF4, 0xB6, 0xAF, 0xCF, 0xD4, 0xCA, 0xBE, 0xC9, 0xE8, 0xD6, 0xC3,
		0xBD, 0xE7, 0xC3, 0xE6, 0x00
	};
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC2A8), aNext, sizeof(aNext));

	//O定  ->  详细设置
	static UCHAR aDetail[] = { 0xCF, 0xEA, 0xCF, 0xB8, 0xC9, 0xE8, 0xD6, 0xC3, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC2DC), aDetail, sizeof(aDetail));

	//起  ->  启动
	static UCHAR aBoot[] = { 0xC6, 0xF4, 0xB6, 0xAF, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC2D4), aBoot, sizeof(aBoot));

	//退出
	static UCHAR aExit[] = { 0xCD, 0xCB, 0xB3, 0xF6, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BC2CC), aExit, sizeof(aExit));
}

VOID PatchBattle()
{
	TDA::DetoursX::DetourAttachFunc(&RawLoadLibraryA, NewLoadLibraryA);
}

VOID PatchBracket()
{
	g_dwBracketRaw = g_dwExeBase + 0x1EB3B;
	g_dwBracketIS = g_dwExeBase + 0x1EB4C;
	g_dwBracketNO = g_dwExeBase + 0x1EADF;
	TDA::MemX::WriteHookCode(g_dwBracketRaw, (DWORD)FixBracket, 5);
}

VOID PatchCharset()
{
	BYTE patchCharSet[] = { 0x86 }; // 0x80 - > 0x86
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x76B6F), patchCharSet, sizeof(patchCharSet));
}

VOID PatchGBK2Unicode()
{
	g_GBK2UnicodeRaw = g_dwExeBase + 0x570F9;
	g_GBK2UnicodeRet = g_dwExeBase + 0x57104;
	TDA::MemX::WriteHookCode(g_GBK2UnicodeRaw, (DWORD)GBK2Unicode, 0xB);
}

VOID PatchCharacterName()
{
	BYTE patchChar1[] = { 0xA1 }; //【 8179 -> A1BE
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x255E9), patchChar1, sizeof(patchChar1));
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x632CB), patchChar1, sizeof(patchChar1));
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x7609E), patchChar1, sizeof(patchChar1));
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x63313), patchChar1, sizeof(patchChar1));
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x25612), patchChar1, sizeof(patchChar1));
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x760FC), patchChar1, sizeof(patchChar1));

	BYTE patchChar2[] = { 0xBE }; //【 8179 -> A1BE
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x632E0), patchChar2, sizeof(patchChar2));
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x255EF), patchChar2, sizeof(patchChar2));
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x760B3), patchChar2, sizeof(patchChar2));

	BYTE patchChar3[] = { 0xBF }; //】 817A -> A1BF
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x63325), patchChar3, sizeof(patchChar3));
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x25619), patchChar3, sizeof(patchChar3));
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x7610E), patchChar3, sizeof(patchChar3));
}

VOID PatchGBKRangeTable()
{
	static unsigned char aTable[256] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00
	};

	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1C2538), aTable, sizeof(aTable));// Code Range Table
}

VOID ScriptFileRedirection()
{
	CHAR scriptPackName[] = "script.cn";// script.dat -> script.cn
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1C1BE8), scriptPackName, sizeof(scriptPackName));
}