#include <Windows.h>

#include "../TDA/MemX.h"
#include "../TDA/DetoursX.h"
#include "../ACV1Extract/ACV1Extract.h"


static DWORD g_dwExeBase = (DWORD)GetModuleHandleW(NULL);


VOID PatchMenu();
VOID PatchUIText();
VOID PatchBracket();
VOID PatchCharset();
VOID PatchGBK2Unicode();
VOID PatchGBKRangeTable();


VOID StartHook()
{
	//TDA::ConsoleX::SetConsole(L"HanaHime");

	PatchMenu();
	PatchUIText();
	PatchBracket();
	PatchCharset();
	PatchGBK2Unicode();
	PatchGBKRangeTable();
	//PatchCharacterName(); // If no change the character name there would be no need to call this func
	//ScriptFileRedirection(); //script.dat -> scrtipt.cn

	SetFileHook("FileHook/", 0xBCF20);
	//SetFileExtract("Extract/");
	//SetFileDump("Dump/");
	SetScriptHook(0xCC1C0, 0xB3B10, "FileHook/Script/");
	//SetScriptDump(0xCC1C0, 0xB3B10, "Dump\\Script\\");

	TDA::DetoursX::HookCreateFontIndirectA(0x86, "黑体");
	TDA::DetoursX::HookTitleExA("@[1.00", "魔法少女まじかるあ`りん1.00");
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		StartHook();
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}

VOID __declspec(dllexport) DirA() {}


static SHORT g_pChar[2] = { 0 };
static WCHAR g_pWChar[2] = { 0 };
static DWORD g_GBK2UnicodeRaw, g_GBK2UnicodeRet;
VOID __declspec(naked) GBK2Unicode()
{
	__asm
	{
		pushad;
		pushfd;
		mov bx, ax;
		shr bx, 8;
		shl ax, 8;
		or ax, bx;
		mov g_pChar, ax;
	}

	MultiByteToWideChar(0x3A8, NULL, (CHAR*)g_pChar, 2, g_pWChar, 2);

	__asm
	{
		popfd
		popad;
		mov ax, g_pWChar;
		jmp g_GBK2UnicodeRet;
	}
}

/*
「    SJIS 0x8175  GBK 0xA1B8
『    SJIS 0x8177  GBK 0xA1BA
（   SJIS 0x8169  GBK 0xA3A8
*/
static DWORD g_dwBracketRaw = 0;
static DWORD g_dwBracketIS = 0;
static DWORD g_dwBracketNO = 0;
VOID __declspec(naked) FixBracket()
{
	__asm
	{
		cmp cl, 0xA1;
		jl NO;
		cmp al, 0xB8;
		je IS;
		cmp al, 0xBA;
		je IS;
		cmp cl, 0xA3;
		jne NO;
		cmp al, 0xA8;
		je IS;

	NO:
		jmp g_dwBracketNO;
	IS:
		jmp g_dwBracketIS;
	}
}

VOID PatchMenu()
{
	// × -> ×
	static UCHAR aX[] = { 0xA1, 0xC1, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B8F54), aX, sizeof(aX));

	// ＋ -> ＋
	static UCHAR aPlus[] = { 0xA3, 0xAB, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B8F50), aPlus, sizeof(aPlus));

	//画面 -> 画面
	static UCHAR aPaint[] = { 0xBB, 0xAD, 0xC3, 0xE6 ,0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B90E8), aPaint, sizeof(aPaint));

	//スクリ`ンモ`ド  ->  显示模式
	static UCHAR aScreenMode[] = { 0xCF, 0xD4, 0xCA, 0xBE, 0xC4, 0xA3, 0xCA, 0xBD, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B902C), aScreenMode, sizeof(aScreenMode));
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B90D4), aScreenMode, sizeof(aScreenMode));

	//ウィンドウ  ->  窗口
	static UCHAR aWindow[] = { 0xB4, 0xB0, 0xBF, 0xDA, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B90C8), aWindow, sizeof(aWindow));

	//フルスクリ`ン  ->  全屏
	static UCHAR aFullScreen[] = { 0xC8, 0xAB, 0xC6, 0xC1, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B90B8), aFullScreen, sizeof(aFullScreen));

	//アスペクト比 16:9  -> 16:9
	static UCHAR a16x9[] = { 0x31, 0x36, 0x3A, 0x39, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B90A4), a16x9, sizeof(a16x9));

	//アスペクト比  4:3  ->  4:3
	static UCHAR a4x3[] = { 0x34, 0x3A, 0x33, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B9090), a4x3, sizeof(a4x3));

	//ウィンドウ位置  ->  窗口位置
	static UCHAR aWindowPosition[] = { 0xB4, 0xB0, 0xBF, 0xDA, 0xCE, 0xBB, 0xD6, 0xC3, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B906C), aWindowPosition, sizeof(aWindowPosition));

	//常に最前面で表示  ->  置顶窗口
	static UCHAR aWindowTop[] = { 0xD6, 0xC3, 0xB6, 0xA5, 0xB4, 0xB0, 0xBF, 0xDA, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B9040), aWindowTop, sizeof(aWindowTop));

	//座摔虮３  ->  保持位置
	static UCHAR aWindowMaintain[] = { 0xB1, 0xA3, 0xB3, 0xD6, 0xCE, 0xBB, 0xD6, 0xC3, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B9054), aWindowMaintain, sizeof(aWindowMaintain));

	//画面の中央  ->  屏幕居中
	static UCHAR aWindowCenter[] = { 0xC6, 0xC1, 0xC4, 0xBB, 0xBE, 0xD3, 0xD6, 0xD0, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B9060), aWindowCenter, sizeof(aWindowCenter));

	//ウィンドウサイズ  ->  窗口大小
	static UCHAR aWindowSize[] = { 0xB4, 0xB0, 0xBF, 0xDA, 0xB4, 0xF3, 0xD0, 0xA1, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B907C), aWindowSize, sizeof(aWindowSize));

	//フルスクリ`ンモ`ド  ->  全屏模式
	static UCHAR aFullScreenMode[] = { 0xC8, 0xAB, 0xC6, 0xC1, 0xC4, 0xA3, 0xCA, 0xBD, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B9028), aFullScreenMode, sizeof(aFullScreenMode));

	//画面大s小ag  ->  缩放算法
	static UCHAR aScaling[] = { 0xCB, 0xF5, 0xB7, 0xC5, 0xCB, 0xE3, 0xB7, 0xA8, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B8FE8), aScaling, sizeof(aScaling));

	//垂直同期待ち  ->  垂直同步
	static UCHAR aSync[] = { 0xB4, 0xB9, 0xD6, 0xB1, 0xCD, 0xAC, 0xB2, 0xBD, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B8F7C), aSync, sizeof(aSync));

	//同期o  ->  关闭同步
	static UCHAR aOffSync[] = { 0xB9, 0xD8, 0xB1, 0xD5, 0xCD, 0xAC, 0xB2, 0xBD, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B8F70), aOffSync, sizeof(aOffSync));

	//サイズ固定  ->  固定大小
	static UCHAR aFixSize[] = { 0xB9, 0xCC, 0xB6, 0xA8, 0xB4, 0xF3, 0xD0, 0xA1, 0x28, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B8F44), aFixSize, sizeof(aFixSize));

	//等倍  ->  原始
	static UCHAR aEqual[] = { 0xD4, 0xAD, 0xCA, 0xBC };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B9155), aEqual, sizeof(aEqual));
}

VOID PatchUIText()
{
	//起釉O定  ->  启动设置
	static UCHAR aBootSetup[] = { 0xC6, 0xF4, 0xB6, 0xAF, 0xC9, 0xE8, 0xD6, 0xC3, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B9420), aBootSetup, sizeof(aBootSetup));

	//スクリ`ンモ`ド  ->  显示模式
	static UCHAR aDisplayMode[] = { 0xCF, 0xD4, 0xCA, 0xBE, 0xC4, 0xA3, 0xCA, 0xBD,0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B902C), aDisplayMode, sizeof(aDisplayMode));
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B90D4), aDisplayMode, sizeof(aDisplayMode));

	//ウィンドウ  ->  窗口
	static UCHAR aWindow[] = { 0xB4, 0xB0, 0xBF, 0xDA, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B90C8), aWindow, sizeof(aWindow));

	//フルスクリ`ン  ->  全屏
	static UCHAR aFullScreen[] = { 0xC8, 0xAB, 0xC6, 0xC1,0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B90B8), aFullScreen, sizeof(aFullScreen));

	//１６：９比率  ->  16:9
	static UCHAR a16x9[] = { 0x31, 0x36, 0xA3, 0xBA, 0x39, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B93DC), a16x9, sizeof(a16x9));

	//４：３比率  ->  4:3
	static UCHAR a4x3[] = { 0x34, 0xA3, 0xBA, 0x33, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B93D0), a4x3, sizeof(a4x3));

	//スクリ`ン解像度  ->  分辨率
	static UCHAR aResolution[] = { 0xB7, 0xD6, 0xB1, 0xE6, 0xC2, 0xCA, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B93BC), aResolution, sizeof(aResolution));

	//ウィンドウサイズをスクリ`ン解像度に合わせる  ->  适配屏幕分辨率
	static UCHAR aAdjustSize[] = { 0xCA, 0xCA, 0xC5, 0xE4, 0xC6, 0xC1, 0xC4, 0xBB, 0xB7, 0xD6, 0xB1, 0xE6, 0xC2, 0xCA, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B9384), aAdjustSize, sizeof(aAdjustSize));

	//注意事项
	//高解像度ではＰＣに通常より高いスペックが求められますので、予めご注意下さい。
	//DBD(Dot By Dot)はディスプレイの１ドットに画像の１ピクセルを表示する事です。
	static UCHAR aNote[] =
	{
		0xB8, 0xDF, 0xB7, 0xD6, 0xB1, 0xE6, 0xC2, 0xCA,
		0xD0, 0xE8, 0xD2, 0xAA, 0xB8, 0xFC, 0xB8, 0xDF, 0xB5, 0xC4, 0xD3, 0xB2, 0xBC, 0xFE, 0xD0, 0xD4,
		0xC4, 0xDC, 0xD6, 0xA7, 0xB3, 0xD6,
		0x0A,
		0x44, 0x42, 0x44, 0x20, 0x28, 0x44, 0x6F, 0x74,
		0x20, 0x42, 0x79, 0x20, 0x44, 0x6F, 0x74, 0x29, 0x20, 0xBC, 0xB4, 0xB5, 0xE3, 0xB6, 0xD4, 0xB5,
		0xE3, 0xCF, 0xD4, 0xCA, 0xBE, 0x00
	};
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B92E8), aNote, sizeof(aNote));

	//存档位置1
	//ドキュメントにセ`ブデ`タを保存しても宜しいですか？
	//ドキュメントをxぶと同じブランドのゲ`ムのセ`ブデ`タが
	//ドキュメントにあればO定を一部引き@げるようになります。
	static UCHAR aSvaePath[] =
	{
		0xCA, 0xC7, 0xB7, 0xF1, 0xC9, 0xE8, 0xD6, 0xC3, 0xCE, 0xC4, 0xB5, 0xB5, 0xCE, 0xAA, 0xB4, 0xE6,
		0xB5, 0xB5, 0xC4, 0xAC, 0xC8, 0xCF, 0xCE, 0xBB, 0xD6, 0xC3, 0xA3, 0xBF,
		0x0A,
		0xD1, 0xA1, 0xB7, 0xF1, 0xBF, 0xC9, 0xD2, 0xD4, 0xC9, 0xE8, 0xD6, 0xC3, 0xB4, 0xE6, 0xB5, 0xB5,
		0xCE, 0xBB, 0xD6, 0xC3, 0xCE, 0xAA, 0xC4, 0xBF, 0xC2, 0xBC, 0xCF, 0xC2, 0x00
	};
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B8E90), aSvaePath, sizeof(aSvaePath));

	//存档位置2
	//ゲ`ムフォルダにセ`ブデ`タを作りますか？
	static UCHAR aSvaePath2[] =
	{
		0xCA, 0xC7, 0xB7, 0xF1, 0xC9, 0xE8, 0xD6, 0xC3, 0xB4, 0xE6, 0xB5, 0xB5, 0xC2, 0xB7, 0xBE, 0xB6,
		0xCE, 0xAA, 0xD3, 0xCE, 0xCF, 0xB7, 0xC4, 0xBF, 0xC2, 0xBC, 0xCF, 0xC2, 0xA3, 0xBF, 0x00,
	};
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B8E38), aSvaePath2, sizeof(aSvaePath2));

	//存档位置3
	//ドキュメントにセ`ブデ`タを作りますか？
	static UCHAR aSvaePath3[] = { 0xB4, 0xE6, 0xB5, 0xB5, 0xC2, 0xB7, 0xBE, 0xB6, 0xCE, 0xAA, 0x0A, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B8E64), aSvaePath3, sizeof(aSvaePath3));

	//次回起rに起釉O定画面を表示する -> 下次启动显示设置界面
	static UCHAR aNext[] =
	{
		0xCF, 0xC2, 0xB4, 0xCE, 0xC6, 0xF4, 0xB6, 0xAF, 0xCF, 0xD4, 0xCA, 0xBE, 0xC9, 0xE8, 0xD6, 0xC3,
		0xBD, 0xE7, 0xC3, 0xE6, 0x00
	};
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B92A8), aNext, sizeof(aNext));

	//O定  ->  详细设置
	static UCHAR aDetail[] = { 0xCF, 0xEA, 0xCF, 0xB8, 0xC9, 0xE8, 0xD6, 0xC3, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B92DC), aDetail, sizeof(aDetail));

	//起  ->  启动
	static UCHAR aBoot[] = { 0xC6, 0xF4, 0xB6, 0xAF, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B92D4), aBoot, sizeof(aBoot));

	//K了  -> 退出
	static UCHAR aExit[] = { 0xCD, 0xCB, 0xB3, 0xF6, 0x00 };
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1B92CC), aExit, sizeof(aExit));
}

VOID PatchBracket()
{
	g_dwBracketRaw = g_dwExeBase + 0x1DFCB;
	g_dwBracketIS = g_dwExeBase + 0x1DFDC;
	g_dwBracketNO = g_dwExeBase + 0x1DF6F;
	TDA::MemX::WriteHookCode(g_dwBracketRaw, (DWORD)FixBracket, 5);
}

VOID PatchCharset()
{
	BYTE patchCharSet[] = { 0x86 }; // 0x80 - > 0x86
	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x74D9F), patchCharSet, sizeof(patchCharSet));
}

VOID PatchGBKRangeTable()
{
	static unsigned char aTable[256] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00
	};

	TDA::MemX::WriteMemory((LPVOID)(g_dwExeBase + 0x1BF440), aTable, sizeof(aTable));// Code Range Table
}

VOID PatchGBK2Unicode()
{
	g_GBK2UnicodeRaw = g_dwExeBase + 0x55D29;
	g_GBK2UnicodeRet = g_dwExeBase + 0x55D34;
	TDA::MemX::WriteHookCode(g_GBK2UnicodeRaw, (DWORD)GBK2Unicode, 0xB);
}

